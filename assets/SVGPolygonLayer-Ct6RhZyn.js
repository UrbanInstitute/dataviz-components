import{S as se,i as ae,s as ue,n as U,r as Y,l as S,e as he}from"./index-Dy1J9qof.js";import{o as Z,p as x,b as $,d as O,j as h,z as j,f as g,i as ee,v as W,n as de,x as fe,A as ye,B as ge}from"./lifecycle-mCW1c9RL.js";import{e as z}from"./each-CjkgdRJJ.js";import{u as A}from"./urbanColors-BkxYcPwH.js";import{g as pe,a as J,b as F,c as T,r as v,d as K}from"./lib-FvRCknQ7.js";function Q(e,t,l){const a=e.slice();return a[35]=t[l],a}function X(e){let t,l,a,y,u,o,n,s;function r(...d){return e[28](e[35],...d)}function k(...d){return e[29](e[35],...d)}return{c(){t=Z("path"),this.h()},l(d){t=x(d,"path",{class:!0,role:!0,label:!0,fill:!0,stroke:!0,"stroke-width":!0,d:!0}),$(t).forEach(O),this.h()},h(){h(t,"class","polygon-feature svelte-1yh1yiv"),h(t,"role",e[9]),h(t,"label",l=e[21](e[35])),h(t,"fill",a=J(e[35],e[0],e[2])),h(t,"stroke",y=F(e[35],e[3])),h(t,"stroke-width",u=e[5]/e[13].k),h(t,"d",o=e[12](e[35])),j(t,"highlight",T(e[35],e[15],e[10])),g(t,"--hover-stroke",e[4]||F(e[35],e[3]))},m(d,f){ee(d,t,f),n||(s=[W(t,"mousemove",r),W(t,"mousedown",k)],n=!0)},p(d,f){e=d,f[0]&512&&h(t,"role",e[9]),f[0]&16512&&l!==(l=e[21](e[35]))&&h(t,"label",l),f[0]&16517&&a!==(a=J(e[35],e[0],e[2]))&&h(t,"fill",a),f[0]&16520&&y!==(y=F(e[35],e[3]))&&h(t,"stroke",y),f[0]&8224&&u!==(u=e[5]/e[13].k)&&h(t,"stroke-width",u),f[0]&20608&&o!==(o=e[12](e[35]))&&h(t,"d",o),f[0]&50304&&j(t,"highlight",T(e[35],e[15],e[10])),f[0]&16536&&g(t,"--hover-stroke",e[4]||F(e[35],e[3]))},d(d){d&&O(t),n=!1,Y(s)}}}function ce(e){let t,l=`${(e[6]||e[5])/e[13].k}px`,a,y,u=z(e[7]||e[14]),o=[];for(let n=0;n<u.length;n+=1)o[n]=X(Q(e,u,n));return{c(){t=Z("g");for(let n=0;n<o.length;n+=1)o[n].c();this.h()},l(n){t=x(n,"g",{class:!0});var s=$(t);for(let r=0;r<o.length;r+=1)o[r].l(s);s.forEach(O),this.h()},h(){h(t,"class","map-layer polygon-layer svelte-1yh1yiv"),j(t,"hover-fill",e[1]),g(t,"--hover-fill",e[1]||null),g(t,"--hover-stroke",e[4]||null),g(t,"--hover-stroke-width",l),g(t,"pointe-events",e[8]?"auto":"none")},m(n,s){ee(n,t,s);for(let r=0;r<o.length;r+=1)o[r]&&o[r].m(t,null);e[32](t),a||(y=[W(t,"mouseout",e[30]),W(t,"blur",e[31])],a=!0)},p(n,s){if(s[0]&14743229){u=z(n[7]||n[14]);let r;for(r=0;r<u.length;r+=1){const k=Q(n,u,r);o[r]?o[r].p(k,s):(o[r]=X(k),o[r].c(),o[r].m(t,null))}for(;r<o.length;r+=1)o[r].d(1);o.length=u.length}s[0]&2&&j(t,"hover-fill",n[1]),s[0]&2&&g(t,"--hover-fill",n[1]||null),s[0]&16&&g(t,"--hover-stroke",n[4]||null),s[0]&8288&&l!==(l=`${(n[6]||n[5])/n[13].k}px`)&&g(t,"--hover-stroke-width",l),s[0]&256&&g(t,"pointe-events",n[8]?"auto":"none")},i:U,o:U,d(n){n&&O(t),de(o,n),e[32](null),a=!1,Y(y)}}}function ke(e,t,l){let a,y,u,o,n;const{projection:s,features:r,transform:k,handleLayerClick:d,handleLayerMousemove:f,stickyHighlight:L}=fe("map");S(e,s,i=>l(27,y=i)),S(e,r,i=>l(14,o=i)),S(e,k,i=>l(13,u=i)),S(e,L,i=>l(15,n=i));let{fill:E=A.blue}=t,{hoverFill:C=void 0}=t,{naFill:V=A.gray_shade_light}=t,{stroke:G=A.white}=t,{hoverStroke:R=void 0}=t,{strokeWidth:P=.5}=t,{hoverStrokeWidth:B=void 0}=t,{features:D=void 0}=t,{pointerEvents:q=!0}=t,{ariaRole:H=void 0}=t,{ariaLabel:b=void 0}=t,{highlightFeature:M=void 0}=t,{tooltip:_=!1}=t;const m=ye();let w,c;function te(i){return typeof b=="string"||typeof b>"u"?b:b(i)}function N(i,p){v(i.target),c&&v(c),_&&f(K(i,p)),m("mousemove",{e:i,props:p.properties})}function I(i,p){v(i.target),c&&v(c),_&&d(K(i,p)),m("click",{e:i,props:p.properties})}ge(()=>{l(26,c=w.querySelector("path.highlight"))});const ie=(i,p)=>N(p,i),ne=(i,p)=>I(p,i),le=i=>m("mouseout"),re=i=>m("mouseout");function oe(i){he[i?"unshift":"push"](()=>{w=i,l(11,w)})}return e.$$set=i=>{"fill"in i&&l(0,E=i.fill),"hoverFill"in i&&l(1,C=i.hoverFill),"naFill"in i&&l(2,V=i.naFill),"stroke"in i&&l(3,G=i.stroke),"hoverStroke"in i&&l(4,R=i.hoverStroke),"strokeWidth"in i&&l(5,P=i.strokeWidth),"hoverStrokeWidth"in i&&l(6,B=i.hoverStrokeWidth),"features"in i&&l(7,D=i.features),"pointerEvents"in i&&l(8,q=i.pointerEvents),"ariaRole"in i&&l(9,H=i.ariaRole),"ariaLabel"in i&&l(24,b=i.ariaLabel),"highlightFeature"in i&&l(10,M=i.highlightFeature),"tooltip"in i&&l(25,_=i.tooltip)},e.$$.update=()=>{e.$$.dirty[0]&134217728&&l(12,a=pe(y)),e.$$.dirty[0]&67108864&&c&&v(c)},[E,C,V,G,R,P,B,D,q,H,M,w,a,u,o,n,s,r,k,L,m,te,N,I,b,_,c,y,ie,ne,le,re,oe]}class be extends se{constructor(t){super(),ae(this,t,ke,ce,ue,{fill:0,hoverFill:1,naFill:2,stroke:3,hoverStroke:4,strokeWidth:5,hoverStrokeWidth:6,features:7,pointerEvents:8,ariaRole:9,ariaLabel:24,highlightFeature:10,tooltip:25},null,[-1,-1])}}be.__docgen={version:3,name:"SVGPolygonLayer.svelte",data:[{visibility:"public",description:"A list of GeoJSON features. By default this component will render the features set in the parent SVGMap, but if `features` is defined, it plots those instead.",keywords:[{name:"type",description:"{Array} [features]"}],name:"features",kind:"const",static:!1,readonly:!0,type:{kind:"type",text:"Array",type:"Array"}},{keywords:[{name:"type",description:"{ (Object) => string | string } [fill = urbanColors.blue] A string or function that returns a string to use as this layers fill color."}],visibility:"public",description:"A color string or a function that takes a feature and returns a color string. Use in combination with a D3 scale for a dynamic color encoding.",name:"fill",kind:"let",static:!1,readonly:!1,type:{kind:"union",text:"(Object) => string | string",type:[{kind:"type",text:"(Object) => string",type:"(Object) => string"},{kind:"type",text:"string",type:"string"}]}},{keywords:[{name:"type",description:"{ string }"}],visibility:"public",description:"Optional color to use for a feature's fill when hovered",name:"hoverFill",kind:"let",static:!1,readonly:!1,type:{kind:"type",text:"string",type:"string"}},{keywords:[{name:"type",description:"{ string }"}],visibility:"public",description:"Color to use for values that are NA or otherwise undefined in the color scale",name:"naFill",kind:"let",static:!1,readonly:!1,type:{kind:"type",text:"string",type:"string"}},{keywords:[{name:"type",description:"{ (Object) => string | string } [fill = urbanColors.blue] A string or function that returns a string to use as this layers stroke color."}],visibility:"public",description:"A color string or a function that takes a feature and returns a color string",name:"stroke",kind:"let",static:!1,readonly:!1,type:{kind:"union",text:"(Object) => string | string",type:[{kind:"type",text:"(Object) => string",type:"(Object) => string"},{kind:"type",text:"string",type:"string"}]}},{keywords:[{name:"type",description:"{ string }"}],visibility:"public",description:"Optional color string for hovered feature stroke",name:"hoverStroke",kind:"let",static:!1,readonly:!1,type:{kind:"type",text:"string",type:"string"}},{keywords:[{name:"type",description:"{ number } [strokeWidth = 0.5]"}],visibility:"public",description:"Stroke width of each feature",name:"strokeWidth",kind:"let",static:!1,readonly:!1,type:{kind:"type",text:"number",type:"number"},defaultValue:.5},{keywords:[{name:"type",description:"{ number } [strokeWidth = undefined]"}],visibility:"public",description:"Stroke width of each feature when hovered",name:"hoverStrokeWidth",kind:"let",static:!1,readonly:!1,type:{kind:"type",text:"number",type:"number"}},{keywords:[{name:"type",description:"{boolean} [pointerEvents]"}],visibility:"public",description:"Boolean that determines if this layer should respond to pointer events and dispatch events.",name:"pointerEvents",kind:"let",static:!1,readonly:!1,type:{kind:"type",text:"boolean",type:"boolean"},defaultValue:!0},{keywords:[{name:"type",description:"{ string } [ariaRole = undefined]"}],visibility:"public",description:"Optional aria role string to be applied to each feature. Defaults to no role, assuming that SVG is hidden from the accessiblity tree.",name:"ariaRole",kind:"let",static:!1,readonly:!1,type:{kind:"type",text:"string",type:"string"}},{keywords:[{name:"type",description:"{ string | (Object) => string } [ariaLabel = undefined]"}],visibility:"public",description:"Optional aria label string or function to be applied to each feature. Defaults to no label, assuming that SVG is hidden from the accessiblity tree. If a function is passed, it should take a `feature` as an argument and return a label string.",name:"ariaLabel",kind:"let",static:!1,readonly:!1,type:{kind:"union",text:"string | (Object) => string",type:[{kind:"type",text:"string",type:"string"},{kind:"type",text:"(Object) => string",type:"(Object) => string"}]}},{keywords:[{name:"type",description:"{{ string: any }}"}],visibility:"public",description:"Optional object that will be compared with each `feature` displayed in the layer. If all of the key/value pairs in `highlightFeature` are equal to the properties of a given `feature`, set that `feature` to a highlighted state.",name:"highlightFeature",kind:"let",static:!1,readonly:!1,type:{kind:"type",text:"{ string: any }",type:"{ string: any }"}},{keywords:[{name:"type",description:"{boolean} [tooltip = false]"}],visibility:"public",description:"Boolean that determines if this layer should populate the tooltip slot when interacted with.",name:"tooltip",kind:"let",static:!1,readonly:!1,type:{kind:"type",text:"boolean",type:"boolean"},defaultValue:!1}],computed:[],methods:[],components:[],description:null,keywords:[],events:[{visibility:"public",description:null,keywords:[],name:"mousemove"},{visibility:"public",description:null,keywords:[],name:"click"},{visibility:"public",description:null,keywords:[],name:"mouseout"}],slots:[],refs:[]};export{be as S};
