import{S as A,i as E,s as j,c as p,a as c,m as i,t as $,b as d,d as g,o as q}from"./index-lamZ5WrB.js";import{s as k,c as H,i as y,d as L,o as S,t as T,g as P,l as U}from"./lifecycle-BNS46k4e.js";import{g as I,a as O}from"./spread-CgU5AtxT.js";import{S as G}from"./SVGLabelLayer-BPnGZMyW.js";import{S as B}from"./lib-BZkmstMI.js";import{f as w,u as _,e as v}from"./index-D9vgTP3q.js";import{p as z,T as J,S as M}from"./collect-stories-D1soPxiK.js";import{s as C}from"./states_geo-Cwuy5VwI.js";import"./each-CxU73AbR.js";import"./urbanColors-BkxYcPwH.js";import"./string-3NetaFjT.js";import"./Tooltip-BmgvXhKp.js";import"./globals-D0QH3NT1.js";const N='A layer that works inside an `SVGMap` component that displays data as a text label layer. If polygon features are passed to this layer, the centroid will be computed with `d3.geoPath.centroid`.\n\n## Basic usage\n\nImport `SVGLabelLayer` and `SVGMap` from this library:\n\n```js\nimport { SVGMap, SVGLabelLayer } from "@urbaninstitute/dataviz-components/maps";\n\n```\nAdd your own GeoJSON data and specify configuration and props seen below. Either use the `getLabel` prop as a function that receives a `feature` as an argument and returns a string to be displayed on the map, or use the default slot and bind to the `props` object with `let:props`.\n\n';function F(o){let e=o[11].STUSPS+"",a;return{c(){a=T(e)},l(t){a=P(t,e)},m(t,r){y(t,a,r)},p(t,r){r&2048&&e!==(e=t[11].STUSPS+"")&&U(a,e)},d(t){t&&L(a)}}}function K(o){let e,a;const t=[o[12]];let r={$$slots:{default:[F,({props:s})=>({11:s}),({props:s})=>s?2048:0]},$$scope:{ctx:o}};for(let s=0;s<t.length;s+=1)r=q(r,t[s]);return e=new G({props:r}),e.$on("click",o[3]),e.$on("mouseout",o[4]),e.$on("mousemove",o[5]),e.$on("click",o[2]),e.$on("mouseout",o[1]),e.$on("mousemove",o[0]),{c(){p(e.$$.fragment)},l(s){c(e.$$.fragment,s)},m(s,u){i(e,s,u),a=!0},p(s,u){const n=u&4096?I(t,[O(s[12])]):{};u&10240&&(n.$$scope={dirty:u,ctx:s}),e.$set(n)},i(s){a||($(e.$$.fragment,s),a=!0)},o(s){d(e.$$.fragment,s),a=!1},d(s){g(e,s)}}}function Q(o){let e,a;return e=new B({props:{features:C.features,$$slots:{default:[K]},$$scope:{ctx:o}}}),{c(){p(e.$$.fragment)},l(t){c(e.$$.fragment,t)},m(t,r){i(e,t,r),a=!0},p(t,r){const s={};r&12288&&(s.$$scope={dirty:r,ctx:t}),e.$set(s)},i(t){a||($(e.$$.fragment,t),a=!0)},o(t){d(e.$$.fragment,t),a=!1},d(t){g(e,t)}}}function R(o){let e=o[11].STUSPS+"",a;return{c(){a=T(e)},l(t){a=P(t,e)},m(t,r){y(t,a,r)},p(t,r){r&2048&&e!==(e=t[11].STUSPS+"")&&U(a,e)},d(t){t&&L(a)}}}function W(o){let e,a;return e=new G({props:{$$slots:{default:[R,({props:t})=>({11:t}),({props:t})=>t?2048:0]},$$scope:{ctx:o}}}),e.$on("click",o[7]),e.$on("mouseout",o[8]),e.$on("mousemove",o[9]),e.$on("click",o[2]),e.$on("mouseout",o[1]),e.$on("mousemove",o[0]),{c(){p(e.$$.fragment)},l(t){c(e.$$.fragment,t)},m(t,r){i(e,t,r),a=!0},p(t,r){const s={};r&10240&&(s.$$scope={dirty:r,ctx:t}),e.$set(s)},i(t){a||($(e.$$.fragment,t),a=!0)},o(t){d(e.$$.fragment,t),a=!1},d(t){g(e,t)}}}function X(o){let e,a;return e=new B({props:{features:C.features,$$slots:{default:[W]},$$scope:{ctx:o}}}),{c(){p(e.$$.fragment)},l(t){c(e.$$.fragment,t)},m(t,r){i(e,t,r),a=!0},p(t,r){const s={};r&8192&&(s.$$scope={dirty:r,ctx:t}),e.$set(s)},i(t){a||($(e.$$.fragment,t),a=!0)},o(t){d(e.$$.fragment,t),a=!1},d(t){g(e,t)}}}function Y(o){let e,a,t,r,s,u;return e=new J({props:{$$slots:{default:[Q,({args:n})=>({12:n}),({args:n})=>n?4096:0]},$$scope:{ctx:o}}}),t=new M({props:{name:"Default",args:{getLabel:x},play:o[6],source:`<SVGMap features={states.features}>
  <SVGLabelLayer getLabel={(feature) => feature.properties.STUSPS}>
    <svelte:fragment let:props>{props.STUSPS}</svelte:fragment>
  </SVGLabelLayer>
</SVGMap>`}}),s=new M({props:{name:"Slot",play:o[10],$$slots:{default:[X]},$$scope:{ctx:o}}}),{c(){p(e.$$.fragment),a=k(),p(t.$$.fragment),r=k(),p(s.$$.fragment)},l(n){c(e.$$.fragment,n),a=H(n),c(t.$$.fragment,n),r=H(n),c(s.$$.fragment,n)},m(n,m){i(e,n,m),y(n,a,m),i(t,n,m),y(n,r,m),i(s,n,m),u=!0},p(n,[m]){const b={};m&12288&&(b.$$scope={dirty:m,ctx:n}),e.$set(b);const h={};m&8192&&(h.$$scope={dirty:m,ctx:n}),s.$set(h)},i(n){u||($(e.$$.fragment,n),$(t.$$.fragment,n),$(s.$$.fragment,n),u=!0)},o(n){d(e.$$.fragment,n),d(t.$$.fragment,n),d(s.$$.fragment,n),u=!1},d(n){n&&(L(a),L(r)),g(e,n),g(t,n),g(s,n)}}}const Z={title:"Maps/SVGLabelLayer",component:G,tags:["autodocs"],argTypes:{features:{control:"array"},stroke:{control:"text"}},parameters:{docs:{description:{component:N}}}},x=o=>o.properties.STUSPS;function ee(o){let e=w(),a=w(),t=w();function r(l){S.call(this,o,l)}function s(l){S.call(this,o,l)}function u(l){S.call(this,o,l)}const n=async({canvasElement:l,args:D})=>{const f=l.querySelector(".label-feature text");await _.hover(f),await v(e).toHaveBeenCalled(),await _.unhover(f),await v(a).toHaveBeenCalled(),await _.click(f),await v(t).toHaveBeenCalled()};function m(l){S.call(this,o,l)}function b(l){S.call(this,o,l)}function h(l){S.call(this,o,l)}return[e,a,t,r,s,u,n,m,b,h,async({canvasElement:l,args:D})=>{const f=l.querySelector(".label-feature text");await _.hover(f),await v(e).toHaveBeenCalled(),await _.unhover(f),await v(a).toHaveBeenCalled(),await _.click(f),await v(t).toHaveBeenCalled()}]}class te extends A{constructor(e){super(),E(this,e,ee,Y,j,{})}}const V=z(te,{meta:{title:"Maps/SVGLabelLayer",tags:["autodocs"]},stories:{"tpl:default":{name:"default",template:!0,source:`<SVGMap features={states.features}>
  <SVGLabelLayer
    {...args}
    on:click
    on:mouseout
    on:mousemove
    on:click={clickHandler}
    on:mouseout={mouseoutHandler}
    on:mousemove={mousemoveHandler}
  >
    <svelte:fragment let:props>{props.STUSPS}</svelte:fragment>
  </SVGLabelLayer>
</SVGMap>`,hasArgs:!0},Default:{name:"Default",template:!1,source:"",hasArgs:!1},Slot:{name:"Slot",template:!1,source:`<SVGMap features={states.features}>
  <SVGLabelLayer
    on:click
    on:mouseout
    on:mousemove
    on:click={clickHandler}
    on:mouseout={mouseoutHandler}
    on:mousemove={mousemoveHandler}
  ><svelte:fragment let:props>{props.STUSPS}</svelte:fragment></SVGLabelLayer>
</SVGMap>`,hasArgs:!1}},allocatedIds:["default","userEvent","expect","fn","Story","Template","states"]},Z),ge=V.meta,Se=["Default","Slot"],_e=V.stories.Default,ve=V.stories.Slot;export{_e as Default,ve as Slot,Se as __namedExportsOrder,ge as default};
