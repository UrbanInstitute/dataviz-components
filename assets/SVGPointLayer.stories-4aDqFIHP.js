import{S as V,i as b,s as w,c as m,a as u,m as p,t as c,b as f,d,o as k}from"./index-Dy1J9qof.js";import{s as L,c as P,i as H,d as M,y as g}from"./lifecycle-mCW1c9RL.js";import{g as C,a as A}from"./spread-CgU5AtxT.js";import{S as h}from"./SVGPointLayer-ioKgmJCL.js";import{S as B}from"./lib-CRabK7jd.js";import{f as _,u as y,e as S}from"./index-D9vgTP3q.js";import{p as T,T as E,S as I}from"./collect-stories-DS3D1-He.js";import{s as j}from"./states_geo-Cwuy5VwI.js";import{u as v}from"./urbanColors-BkxYcPwH.js";import"./each-CjkgdRJJ.js";import"./string-Cinc0syZ.js";import"./Tooltip-DEA9aP6W.js";import"./globals-D0QH3NT1.js";const q='A layer that works inside an `SVGMap` component that displays data as a point/symbol layer. If polygon features are passed to this layer, the centroid will be computed with `d3.geoPath.centroid`.\n\n## Basic usage\n\nImport `SVGPointLayer` and `SVGMap` from this library:\n\n```js\nimport { SVGMap, SVGPointLayer } from "@urbaninstitute/dataviz-components/maps";\n\n```\nAdd your own GeoJSON data and specify configuration and props seen below.\n\n';function O(o){let t,s;const a=[o[7]];let n={};for(let e=0;e<a.length;e+=1)n=k(n,a[e]);return t=new h({props:n}),t.$on("click",o[3]),t.$on("mouseout",o[4]),t.$on("mousemove",o[5]),t.$on("click",o[2]),t.$on("mouseout",o[1]),t.$on("mousemove",o[0]),{c(){m(t.$$.fragment)},l(e){u(t.$$.fragment,e)},m(e,r){p(t,e,r),s=!0},p(e,r){const l=r&128?C(a,[A(e[7])]):{};t.$set(l)},i(e){s||(c(t.$$.fragment,e),s=!0)},o(e){f(t.$$.fragment,e),s=!1},d(e){d(t,e)}}}function z(o){let t,s;return t=new B({props:{features:o[7].features,$$slots:{default:[O]},$$scope:{ctx:o}}}),{c(){m(t.$$.fragment)},l(a){u(t.$$.fragment,a)},m(a,n){p(t,a,n),s=!0},p(a,n){const e={};n&128&&(e.features=a[7].features),n&384&&(e.$$scope={dirty:n,ctx:a}),t.$set(e)},i(a){s||(c(t.$$.fragment,a),s=!0)},o(a){f(t.$$.fragment,a),s=!1},d(a){d(t,a)}}}function D(o){let t,s,a,n;return t=new E({props:{$$slots:{default:[z,({args:e})=>({7:e}),({args:e})=>e?128:0]},$$scope:{ctx:o}}}),a=new I({props:{name:"simple",args:{features:j.features,stroke:v.blue_shade_darker,fill:v.blue,hoverFill:v.magenta},play:o[6]}}),{c(){m(t.$$.fragment),s=L(),m(a.$$.fragment)},l(e){u(t.$$.fragment,e),s=P(e),u(a.$$.fragment,e)},m(e,r){p(t,e,r),H(e,s,r),p(a,e,r),n=!0},p(e,[r]){const l={};r&384&&(l.$$scope={dirty:r,ctx:e}),t.$set(l)},i(e){n||(c(t.$$.fragment,e),c(a.$$.fragment,e),n=!0)},o(e){f(t.$$.fragment,e),f(a.$$.fragment,e),n=!1},d(e){e&&M(s),d(t,e),d(a,e)}}}const F={title:"Maps/SVGPointLayer",component:h,tags:["autodocs"],argTypes:{features:{control:"array"},fill:{control:"text"},stroke:{control:"text"}},parameters:{docs:{description:{component:q}},githubLink:{url:"/maps/SVGPointLayer/SVGPointLayer.svelte"}}};function J(o){let t=_(),s=_(),a=_();function n(i){g.call(this,o,i)}function e(i){g.call(this,o,i)}function r(i){g.call(this,o,i)}return[t,s,a,n,e,r,async({canvasElement:i,args:K})=>{const $=i.querySelector(".point-feature");await y.hover($),await S(t).toHaveBeenCalled(),await y.unhover($),await S(s).toHaveBeenCalled(),await y.click($),await S(a).toHaveBeenCalled()}]}class N extends V{constructor(t){super(),b(this,t,J,D,w,{})}}const G=T(N,{meta:{title:"Maps/SVGPointLayer",tags:["autodocs"]},stories:{"tpl:default":{name:"default",template:!0,source:`<SVGMap features={args.features}>
  <SVGPointLayer
    {...args}
    on:click
    on:mouseout
    on:mousemove
    on:click={clickHandler}
    on:mouseout={mouseoutHandler}
    on:mousemove={mousemoveHandler}
  ></SVGPointLayer>
</SVGMap>`,hasArgs:!0},simple:{name:"simple",template:!1,source:"",hasArgs:!1}},allocatedIds:["default","userEvent","expect","fn","Story","Template","states","urbanColors"]},F),ne=G.meta,re=["simple"],ie=G.stories.simple;export{re as __namedExportsOrder,ne as default,ie as simple};
